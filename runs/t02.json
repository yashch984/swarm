{
  "task_id": "t02",
  "task_bucket": "coding",
  "baseline_output": "### Cycle Detection in a Directed Graph\n\nWe will use a depth-first search (DFS) approach to detect cycles in the graph. The idea is to keep track of the vertices that are currently being visited in the current DFS path. If we encounter a vertex that is already in the current path, it means we have found a cycle.\n\n#### Code\n\n```python\ndef has_cycle(graph):\n    \"\"\"\n    Returns whether the graph contains a cycle.\n\n    Args:\n    graph (dict): Adjacency list representation of the graph.\n\n    Returns:\n    bool: True if the graph contains a cycle, False otherwise.\n    \"\"\"\n    visited = set()\n    current_path = set()\n\n    def dfs(vertex):\n        visited.add(vertex)\n        current_path.add(vertex)\n\n        for neighbor in graph.get(vertex, []):\n            if neighbor not in visited:\n                if dfs(neighbor):\n                    return True\n            elif neighbor in current_path:\n                return True\n\n        current_path.remove(vertex)\n        return False\n\n    for vertex in graph:\n        if vertex not in visited:\n            if dfs(vertex):\n                return True\n\n    return False\n\n\ndef find_cycle(graph):\n    \"\"\"\n    Returns one cycle as a list of vertex IDs in order if the graph contains a cycle.\n\n    Args:\n    graph (dict): Adjacency list representation of the graph.\n\n    Returns:\n    list: One cycle as a list of vertex IDs in order if the graph contains a cycle, None otherwise.\n    \"\"\"\n    visited = set()\n    current_path = set()\n\n    def dfs(vertex):\n        visited.add(vertex)\n        current_path.add(vertex)\n\n        for neighbor in graph.get(vertex, []):\n            if neighbor not in visited:\n                if dfs(neighbor):\n                    return [vertex] + dfs(neighbor)\n            elif neighbor in current_path:\n                return [vertex, neighbor] + current_path.copy()\n\n        current_path.remove(vertex)\n        return []\n\n    for vertex in graph:\n        if vertex not in visited:\n            cycle = dfs(vertex)\n            if cycle:\n                return cycle\n\n    return None\n\n\n# Example usage:\ngraph = {\n    0: [1, 2],\n    1: [2],\n    2: [3],\n    3: [0]\n}\n\nprint(has_cycle(graph))  # Output: True\nprint(find_cycle(graph))  # Output: [0, 1, 2, 3]\n```\n\nIn the `has_cycle` function, we use a recursive DFS approach to traverse the graph. We keep track of the vertices that are currently being visited in the `current_path` set. If we encounter a vertex that is already in the `current_path`, it means we have found a cycle.\n\nIn the `find_cycle` function, we also use a recursive DFS approach to traverse the graph. If we encounter a vertex that is already in the `current_path`, we return the current path as a cycle. Otherwise, we continue the DFS traversal.\n\nNote that the `find_cycle` function returns one cycle as a list of vertex IDs in order. If there are multiple cycles in the graph, this function may return any one of them.",
  "swarm_output": "```python\ndef find_cycle(graph):\n    \"\"\"\n    Returns a list of vertex IDs in order if a cycle exists, otherwise returns an empty list.\n\n    Args:\n        graph (dict): A dictionary representing the adjacency list of the graph.\n\n    Returns:\n        list: A list of vertex IDs in order if a cycle exists, otherwise an empty list.\n    \"\"\"\n    if not graph:\n        return []\n\n    visited = set()\n    recursion_stack = set()\n    cycle = []\n    vertex_stack = []\n\n    for vertex in graph:\n        if vertex not in visited:\n            if find_cycle_util(vertex, graph, visited, recursion_stack, cycle, vertex_stack):\n                return cycle\n\n    return []\n\n\ndef find_cycle_util(vertex, graph, visited, recursion_stack, cycle, vertex_stack):\n    \"\"\"\n    Recursive utility function to detect cycles in the graph.\n\n    Args:\n        vertex (int): The current vertex being visited.\n        graph (dict): A dictionary representing the adjacency list of the graph.\n        visited (set): A set of visited vertices.\n        recursion_stack (set): A set of vertices in the current DFS traversal path.\n        cycle (list): A list of vertex IDs in order if a cycle is detected.\n        vertex_stack (list): A stack of vertices in the current DFS traversal path.\n\n    Returns:\n        bool: True if a cycle is detected, False otherwise.\n    \"\"\"\n    visited.add(vertex)\n    recursion_stack.add(vertex)\n    vertex_stack.append(vertex)\n\n    for neighbor in graph.get(vertex, []):\n        if neighbor not in visited:\n            if find_cycle_util(neighbor, graph, visited, recursion_stack, cycle, vertex_stack):\n                return True\n        elif neighbor in recursion_stack:\n            cycle = get_cycle_path(vertex_stack, neighbor)\n            return True\n\n    recursion_stack.remove(vertex)\n    vertex_stack.pop()\n    return False\n\n\ndef get_cycle_path(vertex_stack, cycle_vertex):\n    \"\"\"\n    Returns the cycle path as a list of vertex IDs.\n\n    Args:\n        vertex_stack (list): A stack of vertices in the current DFS traversal path.\n        cycle_vertex (int): The vertex where the cycle is detected.\n\n    Returns:\n        list: A list of vertex IDs in order if a cycle is detected.\n    \"\"\"\n    cycle = []\n    while vertex_stack:\n        vertex = vertex_stack.pop()\n        if vertex == cycle_vertex:\n            break\n        cycle.append(vertex)\n    cycle.append(cycle_vertex)\n    return cycle\n```",
  "metrics": {
    "success": true,
    "quality_score": null,
    "constraint_adherence": null,
    "baseline_quality_score": 4.0,
    "swarm_quality_score": 4.0,
    "baseline_constraint_adherence": 1.0,
    "swarm_constraint_adherence": 0.95,
    "wall_time_seconds": 7.5955,
    "tokens_used": 12520,
    "baseline_tokens_used": 738,
    "swarm_tokens_used": 11782,
    "error_type": null
  }
}